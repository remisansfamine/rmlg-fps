# **Research paper**
##### Rémi and Jarod working on a scripting system, with binding libraries.
 
# Start
We were asked to link Python Scripts to a C++ project. At first, we started to follow the lesson on Teams to use the Python functions on C++. In order to use C++ functions with Python, we were then suggested to use one of these two technologies that are SWIG or Pybind11. Each member of the group tested one of the technologies.
 
# SWIG (Rémi)
Creating an empty project was the first step. Using the lesson on Teams, SWIG was really easy to implement. One of the major diffculties is that we had to use a new type of file : .i file. Those files are needed to interface functions from C++ to Python. It is at first sight easy to use but finally hard to master and really understand.\
![doti](screenshots/doti_file.png)\
Functions were really easy to bind but classes were not as natural. Another detail that slowed us is that we didn't have the idea to separate the solution into two project at first. We had to modify the main project properties from .exe to .pyd each time we wanted to compile.
 
# Pybind11 (Jarod)
First of all, we had to create an empty solution, to try implementing Pybind11 in the easiest engine, no engine.\
The problem we encountered was understanding that the created module should be a dll in a different project from the main project. In the solution, there are indeed two projects : one to generate the module, and another one to generate the executable.\
![first_pybind_solution](screenshots/first_pybind.png)\
This method just asks us to breate two different project and follow a few documentation to compile and have our first module. But the problem is that no CMake interface were needed because the compilator was directly into Visual Studio.\
We then decided to remove the dll project from the solution. There for, we only needed one project, the executable one. The second project would be stored in a different file, generated by a CMake command line. Understanding and creating a CMakeLists.txt file was the second difficulty.\
![second_pybind_solution](screenshots/second_pybind.png)\
![cmakelists](screenshots/cmakelists.png)\
After finishing the CMake file, we had all we needed :
- an engine : the executable project
- a CMake project : responsible for the modules generation
 
# Our choice
Because SWIG was already partially implemented into the main engine and looked easier to use, we decided to keep this technology instead of Pybind11.\
But before reaching this conclusion, we first made a list of pros and cons of each technology.\

<div style="text-align:center">

![pros_cons](screenshots/pros_cons.png)\
The list was shared as a discord message, modified a couple of times

<div style="text-align:left">

After discovering both libraries, we still didn't really know if a project would generate only one module or multiple ones. It appears that is could only generate one, therefore, we used the projects as they represented their module.
 
# Difficulties post-choice
We tried to facilitate the compilation by creating several projects in the same solution, it seemed to be a good idea but it was not. The compilation time was very long and the static variable no longer worked.
We had not completely understood the DLL system to use it effectively.
 
We had a bug that stucked to us for a long time, where only one line of a function was called.
 
<div style="text-align:center">
 
![Solution](screenshots/solutions.png)\
What our solution looked like with the different projects

![Modules](screenshots/modules.png)\
Different modules were at first implemented, before knowing that singletons were not that easy to use
 
<div style="text-align:left">

# Conclusion
We think SWIG can be really interesting but it was not a good idea for this project and for the use we wanted to make of it. We found the SWIG documentation very complete but it is really difficult to interpret it with our use. The first steps with an empty project were really easy, but with an advanced use (with templates, final and others C++/MCVS keywords), we thing SWIG was much more complex.\
We think the feature of Pybind11 that allows us to bind whatever we want would be useful. We would have a better understanding of what we want to put into a module.\
![binding_with_pybind](screenshots/binding_pybind.png)\
Maybe every member of the team focusing on only one technology would have been a better solution. The only technology would have been chosen based on a quick discovery before any start. Our organization required someone to learn twice.
 
***References***
===
PyHelper:
---
- Helper library to facilitate the use of PyObject pointers and instance:
https://www.codeproject.com/Articles/820116/Embedding-Python-program-in-a-C-Cplusplus-code
 
Swig:
---
- http://www.swig.org/Doc1.3/Python.html#Python_nn4
- http://www.swig.org/Doc1.3/Library.html#Library 
 
Pybind11:
---
- https://github.com/pybind/pybind11
 
C++:
---
- C++ references: https://en.cppreference.com/
 
The screeshots can be found in the directory annexes/screenshots.